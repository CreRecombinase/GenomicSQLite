# Genomics Extension Internals

## Compression layer

*To be written; for now see [sqlite_zstd_vfs](https://github.com/mlin/sqlite_zstd_vfs)*

## Genomic Range Index

The GenomicSQLite GRI is a conventional multi-column B-tree index, organized so that feature overlap with any length distribution is detectable using a series of SQL "between tuples" queries. 

1. Each feature is assigned a "level" *L*, 0 &le; *L* &lt; 16, based simply on its length: *L* = âŒˆlog<sub>16</sub>(length)âŒ‰. Conversely, level *L* consists of all features with 16<sup>L-1</sup> &lt; length &le; 16<sup>L</sup>. (Level 0 has features of length 0 or 1.)
2. The GRI is a multi-column SQL index on each feature's: (chrom, level, position, length)
3. The features on level *L* overlapping a query range (qchrom, qpos, qend) are: ((chrom, level, position) BETWEEN (qchrom, *L*, qbeg - 16<sup>*L*</sup>) AND (qchrom, *L*, qend)) AND position+length &ge; qbeg.
    * <small>SQLite understands this query more-or-less as shown, and plans efficiently to (i) search the index B-tree for the first entry whose tuple (chrom, level, position) &ge; (qchrom, *L*, qbeg-16<sup>*L*</sup>), (ii) scan while it's &le; (qchrom, *L*, qend), and (iii) apply the last filter.</small>
    * <small>Higher levels search exponentially wider position ranges, but they only harbor features of comparable length, and the search cost is a function of the number of features present in the range & level, not the width of the range *per se*.</small>
    * <small>Including each feature's length in the index allows it to determine the precise result set before reading anything from the actual table. Length could be omitted to save space in the GRI, but then more of the indexed table has to be decompressed and filtered to answer each query.</small>
4. Union the disjoint results for *L* between 0 and 15.

We can optimize queries to "fan out" to fewer than 16 levels (which gratuitously admit lengths up to 2<sup>60</sup> nt) by first figuring out the lowest and highest level *actually occupied* by the indexed features. This can be learned during amortized query planning using two quick B-tree searches per chromosome in the existing index. Or, the caller can supply looser bounds based on lengthiest chromosome or other prior knowledge.

The fan-out is only 3 or 4 in many practical datasets. Sometimes it's inflated by a few outlier short features, which e.g. make the bottommost occupied level 0 or 1 instead of 2 or 3. In that case, we can simply make 2 or 3 the lowest level allowed for the table -- that's the `floor` argument to **Create Genomic Range Index**.

One last detail: we negate the level number *L* in the B-tree index, so that when it's built up in genomic range order, smaller (typically more-numerous) features tend to insert into the *rightmost* leaf -- that's usually faster than interior insertions.

This scheme combines the main ideas from [Ensembl's query based on maximum feature length](https://dx.doi.org/10.1093%2Fdatabase%2Fbax020) with the multi-level binning used in [UCSC Genome Browser](https://genome.cshlp.org/content/12/6/996.full), [BAI](https://dx.doi.org/10.1093%2Fbioinformatics%2Fbtp352), [tabix](https://doi.org/10.1093/bioinformatics/btq671), and [bedtools](https://dx.doi.org/10.1093%2Fbioinformatics%2Fbtq033). It addresses the former's sensitivity to outlier lengthy features. And it's simpler than the latter, without effective constraints on feature/chromosome length. A downside is that the index takes more space, storing four values per feature. <small>chrom and level could be consolidated with some loss of flexibility; SQLite stores integers with a variable-length encoding anyway.</small>

### Example query

Here's a GRI subquery on levels 0-2 generated by **Genomic Range Rowids SQL**, using statement parameters (?1, ?2, ?3) = (qchrom, qbeg, qend).

```sql
(SELECT _rowid_ FROM
 (SELECT _rowid_ FROM reads INDEXED BY reads__gri WHERE
   (reads._gri_rid,reads._gri_lvl,reads._gri_beg) BETWEEN
    ((?1),-2,(?2)-0x100) AND ((?1),-2,(?3)-0)
   AND (reads._gri_beg+reads._gri_len) >= (?2)
  UNION ALL
  SELECT _rowid_ FROM reads INDEXED BY reads__gri WHERE
   (reads._gri_rid,reads._gri_lvl,reads._gri_beg) BETWEEN
    ((?1),-1,(?2)-0x10) AND ((?1),-1,(?3)-0)
   AND (reads._gri_beg+reads._gri_len) >= (?2)
  UNION ALL
  SELECT _rowid_ FROM reads INDEXED BY reads__gri WHERE
   (reads._gri_rid,reads._gri_lvl,reads._gri_beg) BETWEEN
    ((?1),-0,(?2)-0x1) AND ((?1),-0,(?3)-0)
   AND (reads._gri_beg+reads._gri_len) >= (?2))
 ORDER BY _rowid_)
```

The `_gri_*` columns are [virtual generated columns](https://sqlite.org/gencol.html) added to the table based on the feature coordinate expressions specified during GRI creation.

The no-op subtraction of 0 from qend was found to be needed for SQLite to use the intended query plan in all cases. So too with the repetition of the length filter constraint, which looks like it should be factored out to the outer SELECT. ðŸ¤·
